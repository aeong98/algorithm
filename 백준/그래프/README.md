# 그래프

- 자료 구조의 일종

- 정점 (Node, vertext)
- 간선 (Edge) : 정점간의 관계를 나타낸다.

- G = (V,E)

---

# 1. 그래프 용어

## 경로, 사이클

- **경로** : 정점 A 에서 B 로 가는 경로
- **사이클** : 정점 A 에서 다시 A 로 돌아오는 경로

## 단순 경로와 단순 사이클
- 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클
- 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다.


## 방향 있는 그래프 (Directed Graph)
- A->C와 같이 간선에 방향이 있다.
- A->C는 있지만, C->A는 없다.

## 방향 없는 그래프 (Undirected Graph)
- A-C 는 A->C, C->A 를 나타낸다.
- 양방향 그래프 (두개의 경로를 모두 저장하게 된다.)

## 간선 여러개 (Multiple Edge)
- 두 정점 사이에 간선이 여러 개일 수도 있다.
- 아래 그림의 A-B 는 연결하는 간선이 2개이다.
- 두 간선은 서로 다른 간선이다.

## 루프
- 간선의 양 끝 점이 같은 경우가 있다.
- 루프

## 가중치
- 간선에 가중치가 있는 경우에는
- A 에서 B 로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등 ..
- 가중치가 없는 경우에는 1이라고 생각


## 차수 (Degree)
- 정점과 연결되어 있는 간선의 개수
- 5의 차수 : 3
- 4의 차수 : 4
- 방향이 있을 경우 in-degree, out-degree

---

# 2.그래프의 표현

- 정점 V개, 간선 E개 (또는 n,m)
- 정점 : 1~V 
- 간선 : 간선을 효율적으로 저장한다. = 어떤 정점과 연결되어 있는 다른 정점을 찾을 수 있다.


## A. 인접 행렬 (Adjacency-matrix)
- 정점의 개수를 V 라고 했을 때,
- V x V 크기의 이차원 배열을 이용한다.
- A[i][j] = 1 (i->j 간선이 있을 때), 0 (없을 때)
- 자주는 사용하지 않음 (없는 간선도 저장하게 되기 때문)
- 공간복잡도 : O(V^2)

## B. 인전 리스트 (Adjacency-list)
- 리스트 뒤에 간선 정보저장
- 인접리스트 : O(E)
- 보통 인접리스트를 사용해 구현

## C. 간선 리스트
- 배열을 이용해서 구현한다.
- 간선을 모두 저장하고있다. 

---

# 3. 그래프의 탐색

- DFS : 깊이 우선 탐색 (최대한 깊숙히 가는 것) (스택) 
- BFS : 너비 우선 탐색 (최대한 넓게 가는 것) (큐) : 모든 가중치 1일 때는, 최단거리 찾는 알고리즘 
- 목적 : 모든 정점을 1번씩 방문함.

# A. 깊이 우선 탐색 (DFS)
- 스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고
- 갈 수 없으면 이전 정점으로 돌아간다.
- check[V] : 방문여부를 체크하는 배열 (O: 아직 방문 X, 1: 방문)
- 스택에 계속 방문한 정점 쌓아두기.
- 더이상 연결된 정점이 없으면 스택에 쌓아 둔 정점 꺼내서, 다시 DFS.
- 스택이 비면 DFS 탐색 종료

1. 인접 행렬을 이용한 구현

```python

def dfs(x):
  check[x]=true
  print(x)
  # 다음 정점을 찾는 과정
  for i in range(1,n+1):
    if (a[x][i] ==1 and check[i]=flase):
        dfs(i)
```
시간복잡도 O(V)*V=O(V^2)

2. 인접 리스트을 이용한 구현

```python
def dfs(x):
  check[x]=true
  for i in range(len(a[x])):
    y=a[x][i]
    if(check[y]==false):
      dfs(y)
```

## B. 너비 우선 탐색 (BFS)
- 큐를 이용해서 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식
- 큐에 **넣을 때** 방문했다고 체크해야 한다.
- check[n] : 방문 체크

```python

def bfs:
  queue=[]
  check[1]=True;
  queue.append(1)
  while (len(queue)>0):
    x=q.pop(0)
    print(x)
    for y in a[x]:
      if(check[y]==False):
        check[y]=True
        queue.append(y)

```

시간복잡도 O(V+E) 보통 E << V

